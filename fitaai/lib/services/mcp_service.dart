import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'dart:convert';

class McpService {
  /// Gets the Supabase client instance
  static SupabaseClient get _supabase => Supabase.instance.client;

  /// Executes a SQL query using the MCP server
  static Future<Map<String, dynamic>> executeQuery(String sql) async {
    try {
      debugPrint('Executing SQL query');
      
      // Using Supabase's run_sql function
      final response = await _supabase.rpc('run_sql', params: {'query': sql});
      return {'success': true, 'data': response};
    } catch (e) {
      debugPrint('Error executing SQL query: $e');
      return {'success': false, 'error': e.toString()};
    }
  }
  
  /// Gets user profile data by user ID
  static Future<Map<String, dynamic>?> getUserProfile(String userId) async {
    try {
      final result = await _supabase
          .from('user_profiles')
          .select()
          .eq('user_id', userId)
          .single();
      
      return result;
    } catch (e) {
      debugPrint('Error fetching user profile: $e');
      return null;
    }
  }
  
  /// Gets the latest workout plan for a user
  static Future<Map<String, dynamic>?> getLatestWorkoutPlan(String userId) async {
    try {
      // Get the latest workout plan for this user
      final planData = await _supabase
          .from('workout_plans')
          .select('*')
          .eq('user_id', userId)
          .order('created_at', ascending: false)
          .limit(1)
          .single();
      
      if (planData == null) return null;
      
      // Get all days and exercises in a single query
      final daysData = await _supabase
          .from('workout_plan_days')
          .select('*, workout_exercises(*)')
          .eq('plan_id', planData['id'])
          .order('day_of_week', ascending: true);
      
      if (daysData == null) return null;
      
      // Reformat the response to match the expected structure
      List<Map<String, dynamic>> formattedDays = [];
      for (var day in daysData) {
        var exercises = day['workout_exercises'] ?? [];
        day.remove('workout_exercises');
        
        Map<String, dynamic> dayWithExercises = Map<String, dynamic>.from(day);
        dayWithExercises['exercises'] = exercises;
        formattedDays.add(dayWithExercises);
      }
      
      // Return the full plan with all days and exercises
      return {
        'plan': planData,
        'days': formattedDays,
      };
    } catch (e) {
      debugPrint('Error fetching workout plan: $e');
      return null;
    }
  }
  
  /// Gets the latest nutrition plan for a user
  static Future<Map<String, dynamic>?> getLatestNutritionPlan(String userId) async {
    try {
      // Get the latest nutrition plan for this user
      final planData = await _supabase
          .from('nutrition_plans')
          .select('*')
          .eq('user_id', userId)
          .order('created_at', ascending: false)
          .limit(1)
          .single();
      
      if (planData == null) return null;
      
      // Get all days and meals in a single query
      final daysData = await _supabase
          .from('nutrition_plan_days')
          .select('*, nutrition_plan_meals(*)')
          .eq('plan_id', planData['id'])
          .order('day_of_week', ascending: true);
      
      if (daysData == null) return null;
      
      // Reformat the response to match the expected structure
      List<Map<String, dynamic>> formattedDays = [];
      for (var day in daysData) {
        var meals = day['nutrition_plan_meals'] ?? [];
        day.remove('nutrition_plan_meals');
        
        Map<String, dynamic> dayWithMeals = Map<String, dynamic>.from(day);
        dayWithMeals['meals'] = meals;
        formattedDays.add(dayWithMeals);
      }
      
      // Return the full plan with all days and meals
      return {
        'plan': planData,
        'days': formattedDays,
      };
    } catch (e) {
      debugPrint('Error fetching nutrition plan: $e');
      return null;
    }
  }
  
  /// Creates a new workout plan in the database
  static Future<String?> createWorkoutPlan(String userId, Map<String, dynamic> plan, Map<String, dynamic> userProfile) async {
    try {
      final planId = plan['id'];
      final now = DateTime.now();
      
      debugPrint('Creating workout plan for user: $userId with plan ID: $planId');
      
      // First, create the main plan record
      await _supabase.from('workout_plans').insert({
        'id': planId,
        'user_id': userId,
        'plan_name': plan['plan_name'] ?? 'Custom Plan',
        'plan_description': plan['plan_description'] ?? 'Generated by AI',
        'plan_type': plan['plan_type'] ?? 'General Fitness',
        'plan_difficulty': userProfile['fitness_level'] ?? 'Intermediate',
        'days_per_week': plan['workout_days']?.length ?? 0,
        'created_at': now.toIso8601String(),
        'updated_at': now.toIso8601String(),
        'start_date': now.toIso8601String().split('T')[0],
        'end_date': now.add(const Duration(days: 28)).toIso8601String().split('T')[0],
      });
      
      debugPrint('Created main workout plan record');
      
      // Create day records sequentially
      if (plan['workout_days'] != null && plan['workout_days'] is List) {
        for (var day in plan['workout_days']) {
          final dayId = day['id'];
          
          // Create the day record
          await _supabase.from('workout_plan_days').insert({
            'id': dayId,
            'plan_id': planId,
            'day_of_week': day['day_of_week'],
            'workout_type': day['workout_type'],
            'session_duration_minutes': day['session_duration_minutes'] ?? 60,
            'estimated_calories': day['estimated_calories'] ?? 300,
            'equipment_needed': day['equipment_needed'] ?? 'Basic gym equipment',
            'notes': day['notes'] ?? 'Follow instructions carefully for each exercise'
          });
          
          debugPrint('Created workout day record for day of week: ${day['day_of_week']}');
          
          // Create exercise records sequentially for this day
          if (day['exercises'] != null && day['exercises'] is List) {
            int exerciseOrder = 0;
            for (var exercise in day['exercises']) {
              try {
                await _supabase.from('workout_exercises').insert({
                  'id': exercise['id'],
                  'day_id': dayId,
                  'exercise_name': exercise['name'],
                  'sets': exercise['sets'],
                  'reps': exercise['reps'],
                  'instructions': exercise['notes'],
                  'rest_seconds': _parseRestTime(exercise['rest']),
                  'exercise_order': exerciseOrder++,
                  'equipment': exercise['equipment'] ?? 'Standard gym equipment',
                  'muscle_group': day['workout_type'],
                });
                
                debugPrint('Created exercise: ${exercise['name']} for day: ${day['day_of_week']}');
              } catch (e) {
                debugPrint('Error creating exercise: ${e.toString()}');
                // Continue creating other exercises even if one fails
              }
            }
          }
        }
      }
      
      debugPrint('Workout plan creation completed successfully');
      return planId;
    } catch (e) {
      debugPrint('Error creating workout plan: $e');
      return null;
    }
  }
  
  /// Creates a new nutrition plan in the database
  static Future<String?> createNutritionPlan(String userId, Map<String, dynamic> plan) async {
    try {
      final planId = plan['id'];
      final now = DateTime.now();
      
      debugPrint('Creating nutrition plan for user: $userId with plan ID: $planId');
      
      // Extract macro information
      final dailyCalories = plan['total_daily_calories'] ?? 2000;
      final proteinGrams = plan['protein_daily_grams'] ?? 150;
      final carbsGrams = plan['carbs_daily_grams'] ?? 200;
      final fatGrams = plan['fat_daily_grams'] ?? 70;
      final mealsPerDay = plan['meals_per_day'] ?? 3;
      
      // First, create the main plan record
      await _supabase.from('nutrition_plans').insert({
        'id': planId,
        'user_id': userId,
        'total_daily_calories': dailyCalories,
        'protein_daily_grams': proteinGrams,
        'carbs_daily_grams': carbsGrams,
        'fat_daily_grams': fatGrams,
        'meals_per_day': mealsPerDay,
        'plan_notes': plan['plan_notes'] ?? 'Nutrition Plan',
        'created_at': now.toIso8601String(),
        'updated_at': now.toIso8601String(),
        'start_date': now.toIso8601String().split('T')[0],
        'end_date': now.add(const Duration(days: 28)).toIso8601String().split('T')[0],
      });
      
      debugPrint('Created main nutrition plan record');
      
      // Create day and meal records sequentially
      if (plan['nutrition_days'] != null && plan['nutrition_days'] is List) {
        for (var day in plan['nutrition_days']) {
          final dayId = day['id'];
          
          // Create the day record
          await _supabase.from('nutrition_plan_days').insert({
            'id': dayId,
            'plan_id': planId,
            'day_of_week': day['day_of_week'],
            'total_calories': day['total_calories'] ?? dailyCalories,
            'total_protein': day['macro_split']?['protein_g'] ?? proteinGrams,
            'total_carbs': day['macro_split']?['carbs_g'] ?? carbsGrams,
            'total_fat': day['macro_split']?['fats_g'] ?? fatGrams,
            'notes': day['notes'] ?? '',
          });
          
          debugPrint('Created nutrition day record for day of week: ${day['day_of_week']}');
          
          // Create meal records sequentially for this day
          if (day['meals'] != null && day['meals'] is List) {
            for (var meal in day['meals']) {
              try {
                await _supabase.from('nutrition_plan_meals').insert({
                  'id': meal['id'],
                  'day_id': dayId,
                  'meal_name': meal['meal_name'],
                  'meal_time': meal['meal_time'],
                  'total_calories': meal['calories'],
                  'protein_grams': _calculateTotalNutrient(meal['foods'], 'protein'),
                  'carbs_grams': _calculateTotalNutrient(meal['foods'], 'carbs'),
                  'fat_grams': _calculateTotalNutrient(meal['foods'], 'fat'),
                  'description': meal['description'] ?? '',
                  'foods': meal['foods'] ?? [],
                });
                
                debugPrint('Created meal: ${meal['meal_name']} for day: ${day['day_of_week']}');
              } catch (e) {
                debugPrint('Error creating meal: ${e.toString()}');
                // Continue creating other meals even if one fails
              }
            }
          }
        }
      }
      
      debugPrint('Nutrition plan creation completed successfully');
      return planId;
    } catch (e) {
      debugPrint('Error creating nutrition plan: $e');
      return null;
    }
  }
  
  /// Helper function to parse rest time from string to seconds
  static int _parseRestTime(String? restTime) {
    if (restTime == null) return 60;
    
    try {
      // Parse formats like "60 seconds" or "60s"
      final numericPart = RegExp(r'(\d+)').firstMatch(restTime);
      if (numericPart != null) {
        return int.parse(numericPart.group(1)!);
      }
    } catch (_) {}
    
    return 60; // Default rest time
  }
  
  /// Helper function to calculate total nutrients from a list of foods
  static int _calculateTotalNutrient(List<dynamic>? foods, String nutrient) {
    if (foods == null || foods.isEmpty) return 0;
    
    int total = 0;
    for (var food in foods) {
      if (food is Map && food.containsKey(nutrient)) {
        final value = food[nutrient];
        if (value is int) {
          total += value;
        } else if (value is String) {
          try {
            total += int.parse(value);
          } catch (_) {}
        }
      }
    }
    
    return total;
  }
  
  /// Updates the instructions for an exercise
  static Future<bool> updateExerciseInstructions(String exerciseId, String newInstructions) async {
    try {
      await _supabase
          .from('workout_exercises')
          .update({
            'instructions': newInstructions
          })
          .eq('id', exerciseId);
      return true;
    } catch (e) {
      debugPrint('Error updating exercise instructions: $e');
      return false;
    }
  }
  
  /// Adds a new exercise to a workout day
  static Future<bool> addExerciseToWorkoutDay(
    String dayId,
    String exerciseName,
    int sets,
    String reps,
    String instructions,
    int restSeconds
  ) async {
    try {
      // Get highest exercise order
      int maxOrder = 0;
      final existingExercises = await _supabase
          .from('workout_exercises')
          .select('exercise_order')
          .eq('day_id', dayId);
      
      for (var ex in existingExercises) {
        if (ex['exercise_order'] > maxOrder) {
          maxOrder = ex['exercise_order'];
        }
      }
      
      // Generate a UUID for the new exercise
      final exerciseId = _generateUuid();
      
      // Add the new exercise
      await _supabase
          .from('workout_exercises')
          .insert({
            'id': exerciseId,
            'day_id': dayId,
            'exercise_name': exerciseName,
            'sets': sets,
            'reps': reps,
            'rest_seconds': restSeconds,
            'instructions': instructions,
            'exercise_order': maxOrder + 1,
            'muscle_group': 'Added via chat', // Default value
          });
      
      return true;
    } catch (e) {
      debugPrint('Error adding exercise to workout day: $e');
      return false;
    }
  }
  
  /// Removes an exercise from a workout
  static Future<bool> removeExerciseFromWorkout(String exerciseId) async {
    try {
      await _supabase
          .from('workout_exercises')
          .delete()
          .eq('id', exerciseId);
      
      return true;
    } catch (e) {
      debugPrint('Error removing exercise from workout: $e');
      return false;
    }
  }
  
  /// Updates an exercise in a workout
  static Future<bool> updateExercise(
    String exerciseId,
    int? sets,
    String? reps,
    String? instructions,
    int? restSeconds
  ) async {
    try {
      Map<String, dynamic> updateData = {};
      
      if (sets != null) updateData['sets'] = sets;
      if (reps != null) updateData['reps'] = reps;
      if (instructions != null) updateData['instructions'] = instructions;
      if (restSeconds != null) updateData['rest_seconds'] = restSeconds;
      
      if (updateData.isEmpty) return false;
      
      await _supabase
          .from('workout_exercises')
          .update(updateData)
          .eq('id', exerciseId);
      
      return true;
    } catch (e) {
      debugPrint('Error updating exercise: $e');
      return false;
    }
  }
  
  /// Updates nutrition plan macros
  static Future<bool> updateNutritionPlanMacros(
    String planId,
    int calories,
    int protein,
    int carbs,
    int fat
  ) async {
    try {
      await _supabase
          .from('nutrition_plans')
          .update({
            'total_daily_calories': calories,
            'protein_daily_grams': protein,
            'carbs_daily_grams': carbs,
            'fat_daily_grams': fat,
            'updated_at': DateTime.now().toIso8601String(),
          })
          .eq('id', planId);
      
      return true;
    } catch (e) {
      debugPrint('Error updating nutrition plan macros: $e');
      return false;
    }
  }
  
  /// Adds a meal to a nutrition plan day
  static Future<bool> addMealToNutritionDay(
    String dayId,
    String mealName,
    String mealTime,
    int calories,
    int protein,
    int carbs,
    int fat,
    String description
  ) async {
    try {
      // Generate a UUID for the new meal
      final mealId = _generateUuid();
      
      // Add the new meal
      await _supabase
          .from('nutrition_plan_meals')
          .insert({
            'id': mealId,
            'day_id': dayId,
            'meal_name': mealName,
            'meal_time': mealTime,
            'total_calories': calories,
            'protein_grams': protein,
            'carbs_grams': carbs,
            'fat_grams': fat,
            'description': description,
          });
      
      return true;
    } catch (e) {
      debugPrint('Error adding meal to nutrition day: $e');
      return false;
    }
  }
  
  /// Removes a meal from a nutrition plan
  static Future<bool> removeMealFromNutritionPlan(String mealId) async {
    try {
      await _supabase
          .from('nutrition_plan_meals')
          .delete()
          .eq('id', mealId);
      
      return true;
    } catch (e) {
      debugPrint('Error removing meal from nutrition plan: $e');
      return false;
    }
  }
  
  /// Updates a meal in a nutrition plan
  static Future<bool> updateMeal(
    String mealId,
    String? mealName,
    String? mealTime,
    int? calories,
    int? protein,
    int? carbs,
    int? fat,
    String? description
  ) async {
    try {
      Map<String, dynamic> updateData = {};
      
      if (mealName != null) updateData['meal_name'] = mealName;
      if (mealTime != null) updateData['meal_time'] = mealTime;
      if (calories != null) updateData['total_calories'] = calories;
      if (protein != null) updateData['protein_grams'] = protein;
      if (carbs != null) updateData['carbs_grams'] = carbs;
      if (fat != null) updateData['fat_grams'] = fat;
      if (description != null) updateData['description'] = description;
      
      if (updateData.isEmpty) return false;
      
      await _supabase
          .from('nutrition_plan_meals')
          .update(updateData)
          .eq('id', mealId);
      
      return true;
    } catch (e) {
      debugPrint('Error updating meal: $e');
      return false;
    }
  }
  
  /// Generates a UUID for new records
  static String _generateUuid() {
    // Simple UUID generation
    final now = DateTime.now().millisecondsSinceEpoch;
    final random = DateTime.now().microsecondsSinceEpoch;
    return '$now-$random';
  }
} 